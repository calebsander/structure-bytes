<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/growable-buffer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/growable-buffer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const assert = require(__dirname + '/assert.js');

const INITIAL_LENGTH = 10;

/**
 * A {@link StringBuilder}-like object which
 * automatically grows its internal buffer
 * as bytes are added.
 * Used extensively throughout the project
 * for building up buffers.
 * @see GrowableBuffer#grow
 * for explanation of the growing process
 */
class GrowableBuffer {
	/**
	 * @param {number} [initialLength=10]
	 * The number of bytes in the internal buffer at start
	 */
	constructor(initialLength = INITIAL_LENGTH) {
		assert.integer(initialLength);
		assert.between(0, initialLength, Number.MAX_SAFE_INTEGER, String(initialLength) + ' is not a valid buffer length');
		this.buffer = Buffer.allocUnsafe(initialLength);
		this.size = 0;
	}

	/**
	 * The current number of bytes being occupied.
	 * Note that this is NOT the size of the internal buffer.
	 * @readonly
	 * @type number
	 */
	get length() {
		return this.size;
	}
	/**
	 * Grow the internal buffer to hold
	 * at least the specified number of bytes.
	 * If the internal buffer is too small,
	 * it will be resized to {@link size*2}
	 * This is called internally when needed,
	 * but if the program knows it will need a lot of space eventually,
	 * this method can be called explicitly.
	 * @param {number} size An inclusive lower bound on the number of bytes
	 * in the internal buffer after the method returns
	 * @return {GrowableBuffer} {@link this}
	 */
	grow(size) {
		assert.integer(size);
		if (size > this.buffer.length) {
			const newBuffer = Buffer.allocUnsafe(size &lt;&lt; 1);
			this.buffer.copy(newBuffer, 0, 0, this.size);
			this.buffer = newBuffer;
		}
		return this;
	}
	/**
	 * Sets a byte's value.
	 * The byte must lie in the occupied portion
	 * of the internal buffer.
	 * @param {number} index The position of the byte (0-indexed)
	 * @param {number} value The value to set the byte to
	 * (must fit in an unsigned byte)
	 * @return {GrowableBuffer} {@link this}
	 */
	set(index, value) {
		assert.integer(index);
		assert.integer(value);
		assert.between(0, index, this.size, 'Index out of bounds: ' + String(index));
		assert.between(0, value, 0x100, 'Not a byte: ' + String(value));
		this.buffer.writeUInt8(value, index);
		return this;
	}
	/**
	 * Sets a set of contiguous bytes' values.
	 * Each byte must lie in the occupied portion
	 * of the internal buffer.
	 * @param {number} index The position of the first byte (0-indexed)
	 * @param {external:Buffer} buffer The values to write, starting at {@link index}
	 * (the byte at position {@link i} in {@link buffer} will be written to
	 * position {@link index+i} of the {@link GrowableBuffer})
	 * @return {GrowableBuffer} {@link this}
	 */
	setAll(index, buffer) {
		assert.instanceOf(buffer, Buffer);
		assert.integer(index);
		assert.between(0, index, this.size - buffer.length + 1, 'Index out of bounds: ' + String(index));
		buffer.copy(this.buffer, index);
	}
	/**
	 * Gets a byte's value.
	 * The byte must lie in the occupied portion
	 * of the internal buffer.
	 * @param {number} index The position of the byte (0-indexed)
	 * @return {number} the unsigned byte at the specified index
	 * of the internal buffer
	 */
	get(index) {
		assert.integer(index);
		assert.between(0, index, this.size, 'Index out of bounds: ' + String(index));
		return this.buffer.readUInt8(index);
	}
	/**
	 * Adds a byte after the end of the
	 * occupied portion of the internal buffer
	 * @param {number} value The unsigned byte value to add
	 * @return {GrowableBuffer} {@link this}
	 */
	add(value) {
		const oldSize = this.size;
		const newSize = oldSize + 1;
		this.grow(newSize);
		this.size = newSize;
		this.set(oldSize, value);
		return this;
	}
	/**
	 * Adds a contiguous set of bytes after
	 * the end of the occupied portion
	 * of the internal buffer
	 * @param {external:Buffer} buffer The bytes to add
	 * the byte at position {@link i} in {@link buffer} will be written to
	 * position {@link this.length+i} of the {@link GrowableBuffer})
	 * @return {GrowableBuffer} {@link this}
	 */
	addAll(buffer) {
		assert.instanceOf(buffer, Buffer);
		const oldSize = this.size;
		const newSize = this.size + buffer.length;
		this.grow(newSize);
		this.size = newSize;
		buffer.copy(this.buffer, oldSize);
		return this;
	}
	/**
	 * Gets the internal buffer to avoid calling {@link Buffer#slice}
	 * @private
	 * @readonly
	 * @type {external:Buffer}
	 */
	get rawBuffer() {
		return this.buffer;
	}
	/**
	 * Gets the occupied portion in {@link Buffer} form.
	 * @return {external:Buffer} The internal buffer trimmed to
	 * [this.length]{@link GrowableBuffer#length}
	 */
	toBuffer() {
		return this.buffer.slice(0, this.size);
	}
};
module.exports = GrowableBuffer;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-Buffer.html">Buffer</a></li><li><a href="external-http.html">http</a></li></ul><h3>Classes</h3><ul><li><a href="ArrayType.html">ArrayType</a></li><li><a href="BooleanArrayType.html">BooleanArrayType</a></li><li><a href="BooleanTupleType.html">BooleanTupleType</a></li><li><a href="BooleanType.html">BooleanType</a></li><li><a href="BufferStream.html">BufferStream</a></li><li><a href="ByteType.html">ByteType</a></li><li><a href="CharType.html">CharType</a></li><li><a href="ChoiceType.html">ChoiceType</a></li><li><a href="DateType.html">DateType</a></li><li><a href="DoubleType.html">DoubleType</a></li><li><a href="EnumType.html">EnumType</a></li><li><a href="external-http.IncomingMessage.html">IncomingMessage</a></li><li><a href="external-http.ServerResponse.html">ServerResponse</a></li><li><a href="FloatType.html">FloatType</a></li><li><a href="GrowableBuffer.html">GrowableBuffer</a></li><li><a href="IntType.html">IntType</a></li><li><a href="LongType.html">LongType</a></li><li><a href="MapType.html">MapType</a></li><li><a href="OctetsType.html">OctetsType</a></li><li><a href="OptionalType.html">OptionalType</a></li><li><a href="PointerType.html">PointerType</a></li><li><a href="SetType.html">SetType</a></li><li><a href="ShortType.html">ShortType</a></li><li><a href="StringType.html">StringType</a></li><li><a href="StructType.html">StructType</a></li><li><a href="TupleType.html">TupleType</a></li><li><a href="Type.html">Type</a></li><li><a href="UnsignedByteType.html">UnsignedByteType</a></li><li><a href="UnsignedIntType.html">UnsignedIntType</a></li><li><a href="UnsignedLongType.html">UnsignedLongType</a></li><li><a href="UnsignedShortType.html">UnsignedShortType</a></li></ul><h3>Namespaces</h3><ul><li><a href="r.html">r</a></li></ul><h3>Global</h3><ul><li><a href="global.html#httpRespond">httpRespond</a></li><li><a href="global.html#readType">readType</a></li><li><a href="global.html#readTypeAndValue">readTypeAndValue</a></li><li><a href="global.html#readValue">readValue</a></li><li><a href="global.html#writeType">writeType</a></li><li><a href="global.html#writeTypeAndValue">writeTypeAndValue</a></li><li><a href="global.html#writeValue">writeValue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
