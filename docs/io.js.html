<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: io.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: io.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//For use with browserify
if (__dirname === '/') __dirname = ''

//This file contains functions for performing I/O;
//specifically, reads and writes of types and values and HTTP responses

const accepts = require('accepts')
const assert = require(__dirname + '/lib/assert.js')
const BufferStream = require(__dirname + '/lib/buffer-stream.js')
const GrowableBuffer = require(__dirname + '/lib/growable-buffer.js')
const http = require('http')
const r = require(__dirname + '/read.js')
const stream = require('stream')
const t = require(__dirname + '/structure-types.js')
const zlib = require('zlib')

function toArrayBuffer(buffer) {
	return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)
}
const WRITABLE_STREAMS = [stream.Writable, stream.Duplex, http.ServerResponse]

const io = module.exports = {
	/**
	 * A callback that receives an error object, if any was thrown.
	 * @callback errCallback
	 * @param {null|Error} err The error (if any) that occurred
	 */
	/** @function
	 * @name writeType
	 * @desc Writes type bytes to a writable stream.
	 * Writes the contents of [type.toBuffer()]{@link Type#toBuffer}
	 * followed by a null byte.
	 * Calls {@link callback} when done.
	 * @param {{type, outStream}} params
	 * @param {Type} params.type The type to write
	 * @param {stream.Writable} params.outStream The stream to write to
	 * @param {errCallback=} callback
	 * @return {stream.Writable} {@link params.outStream}
	 */
	writeType({type, outStream}, callback) {
		assert.instanceOf(type, t.Type)
		assert.instanceOf(outStream, WRITABLE_STREAMS)
		if (callback === undefined) callback = () => {}
		assert.instanceOf(callback, Function)
		const typeStream = new BufferStream(type.toBuffer())
		return typeStream.pipe(outStream).on('error', function(err) {
			this.end()
			callback(err)
		}).on('finish', () => callback(null))
	},
	/** @function
	 * @name writeValue
	 * @desc Writes value bytes to a writable stream.
	 * Writes the contents of [type.valueBuffer(value)]{@link Type#valueBuffer}
	 * followed by a null byte.
	 * Calls {@link callback} when done.
	 * @param {{type, value, outStream}} params
	 * @param {Type} params.type The type to use to write the value
	 * @param {type} params.value The value to write
	 * @param {stream.Writable} params.outStream The stream to write to
	 * @param {errCallback=} callback
	 * @return {stream.Writable} {@link params.outStream}
	 */
	writeValue({type, value, outStream}, callback) {
		assert.instanceOf(type, t.Type)
		assert.instanceOf(outStream, WRITABLE_STREAMS)
		if (callback === undefined) callback = () => {}
		assert.instanceOf(callback, Function)
		const valueBuffer = new GrowableBuffer
		type.writeValue(valueBuffer, value)
		return new BufferStream(valueBuffer).pipe(outStream).on('error', function(err) {
			this.end()
			callback(err)
		}).on('finish', () => callback(null))
	},
	/** @function
	 * @name writeTypeAndValue
	 * @desc Writes both type and value bytes to a writable stream.
	 * Writes the contents of [type.toBuffer()]{@link Type#toBuffer},
	 * followed by the contents of [type.valueBuffer(value)]{@link Type#valueBuffer},
	 * and then a null byte.
	 * Calls {@link callback} when done.
	 * @param {{type, value, outStream}} params
	 * @param {Type} params.type The type to write
	 * and to use to write the value
	 * @param {type} params.value The value to write
	 * @param {stream.Writable} params.outStream The stream to write to
	 * @param {errCallback=} callback
	 * @return {stream.Writable} {@link params.outStream}
	 */
	writeTypeAndValue({type, value, outStream}, callback) {
		assert.instanceOf(type, t.Type)
		assert.instanceOf(outStream, WRITABLE_STREAMS)
		if (callback === undefined) callback = () => {}
		assert.instanceOf(callback, Function)
		const typeStream = new BufferStream(type.toBuffer())
		typeStream.pipe(outStream, {end: false}).on('error', function() {
			this.end()
		})
		typeStream.on('bs-written', () => { //can't listen for finish because it isn't called on a pipe without an end
			io.writeValue({type, value, outStream}, callback)
		})
		return outStream
	},
	/**
	 * A callback that receives an error object, if any was thrown,
	 * and a type, if no error was thrown.
	 * @callback typeCallback
	 * @param {null|Error} err The error (if any) that occurred
	 * @param {null|Type} type The type that was read
	 */
	/** @function
	 * @name readType
	 * @desc Reads a type from a readable stream.
	 * This should be used when reading from sources
	 * written to by {@link writeType}.
	 * Calls {@link callback} with the type when done.
	 * @param {stream.Readable} inStream The stream to read from
	 * @param {typeCallback} callback
	 */
	readType(inStream, callback) {
		assert.instanceOf(inStream, stream.Readable)
		assert.instanceOf(callback, Function)
		const segments = []
		inStream.on('data', chunk => segments.push(chunk))
		inStream.on('error', function(err) {
			this.destroy()
			callback(err, null)
		})
		inStream.on('end', () => {
			const buffer = Buffer.concat(segments)
			let type
			try { type = r.type(toArrayBuffer(buffer), false) }
			catch (e) { return callback(e, null) }
			callback(null, type) //if error occurred, don't callback with a null type
		})
	},
	/**
	 * A callback that receives an error object, if any was thrown,
	 * and a value, if no error was thrown.
	 * @callback valueCallback
	 * @param {null|Error} err The error (if any) that occurred
	 * @param {null|type} value The value that was read
	 */
	/** @function
	 * @name readValue
	 * @desc Reads a value from a readable stream.
	 * The {@link Type} used to write the value bytes must be known.
	 * This should be used when reading from sources
	 * written to by {@link writeValue}.
	 * Calls {@link callback} with the value when done.
	 * @param {{type, inStream}} params
	 * @param {Type} params.type The type that wrote the value bytes
	 * @param {stream.Readable} params.inStream The stream to read from
	 * @param {valueCallback} callback
	 */
	readValue({type, inStream}, callback) {
		assert.instanceOf(inStream, stream.Readable)
		assert.instanceOf(callback, Function)
		const segments = []
		inStream.on('data', chunk => segments.push(chunk))
		inStream.on('error', function(err) {
			this.destroy()
			callback(err, null)
		})
		inStream.on('end', () => {
			const buffer = Buffer.concat(segments)
			let value
			try { value = r.value({buffer: toArrayBuffer(buffer), type}) }
			catch (e) { return callback(e, null) }
			callback(null, value) //if error occurred, don't callback with a null value
		})
	},
	/**
	 * A callback that receives an error object, if any was thrown,
	 * and a type and value, if no error was thrown.
	 * @callback typeAndValueCallback
	 * @param {null|Error} err The error (if any) that occurred
	 * @param {null|Type} type The type that was read
	 * @param {null|type} value The value that was read
	 */
	/** @function
	 * @name readTypeAndValue
	 * @desc Reads a type and a value from a readable stream.
	 * This should be used when reading from sources
	 * written to by {@link writeTypeAndValue}.
	 * Calls {@link callback} with the type and value when done.
	 * @param {stream.Readable} inStream The stream to read from
	 * @param {typeAndValueCallback} callback
	 */
	readTypeAndValue(inStream, callback) {
		assert.instanceOf(inStream, stream.Readable)
		assert.instanceOf(callback, Function)
		const segments = []
		inStream.on('data', chunk => segments.push(chunk))
		inStream.on('error', function(err) {
			this.destroy()
			callback(err, null, null)
		})
		inStream.on('end', () => {
			const buffer = Buffer.concat(segments)
			let type
			//Using consumeType() in order to get the length of the type (the start of the value)
			try { type = r._consumeType(toArrayBuffer(buffer), 0) }
			catch (e) { return callback(e, null, null) }
			let value
			try { value = r.value({buffer: toArrayBuffer(buffer), offset: type.length, type: type.value}) }
			catch (e) { return callback(e, null, null) }
			callback(null, type.value, value) //if error occurred, don't callback with null value or type
		})
	},
	/** @function
	 * @name httpRespond
	 * @desc Responds to an HTTP(S) request for a value.
	 * Will send both type and value if the {@link sig} header
	 * doesn't match the type's signature.
	 * Will only send the value if the signatures match.
	 * Response is gzipped to decrease size.
	 * Calls {@link callback} when done.
	 * @param {{req, res, type, value}} params
	 * @param {external:http.IncomingMessage} params.req The client request
	 * @param {external:http.ServerResponse} params.res The server response
	 * @param {Type} params.type The type of the message
	 * @param {type} params.value The value to send
	 * @param {errCallback=} callback
	 */
	httpRespond({req, res, type, value}, callback) {
		function writeEndCallback(acceptsGzip) {
			return err => {
				if (err) callback(err)
				if (!acceptsGzip) callback(null)
			}
		}
		assert.instanceOf(type, t.Type)
		if (callback === undefined) callback = () => {}
		assert.instanceOf(callback, Function)
		assert.instanceOf(req, http.IncomingMessage)
		assert.instanceOf(res, http.ServerResponse)
		try {
			res.setHeader('Content-Type', 'application/octet-stream')
			res.setHeader('sig', type.getSignature())
			const acceptsGzip = accepts(req).encoding(['gzip'])
			let outStream
			if (acceptsGzip) {
				res.setHeader('Content-Encoding', 'gzip')
				outStream = zlib.createGzip() //pipe into a zip stream to decrease size of response
			}
			else outStream = res
			if (req.headers.sig &amp;&amp; req.headers.sig === type.getSignature()) { //if client already has type, only value needs to be sent
				io.writeValue({type, value, outStream}, writeEndCallback(acceptsGzip))
			}
			else io.writeTypeAndValue({type, value, outStream}, writeEndCallback(acceptsGzip)) //otherwise, type and value need to be sent
			if (acceptsGzip) outStream.pipe(res).on('finish', () => callback(null)) //don't pipe until writing begins
		}
		catch (err) { callback(err) }
	}
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-ArrayBuffer.html">ArrayBuffer</a></li><li><a href="external-Date.html">Date</a></li><li><a href="external-http.html">http</a></li></ul><h3>Classes</h3><ul><li><a href="ArrayType.html">ArrayType</a></li><li><a href="BigIntType.html">BigIntType</a></li><li><a href="BigUnsignedIntType.html">BigUnsignedIntType</a></li><li><a href="BooleanArrayType.html">BooleanArrayType</a></li><li><a href="BooleanTupleType.html">BooleanTupleType</a></li><li><a href="BooleanType.html">BooleanType</a></li><li><a href="BufferStream.html">BufferStream</a></li><li><a href="ByteType.html">ByteType</a></li><li><a href="CharType.html">CharType</a></li><li><a href="ChoiceType.html">ChoiceType</a></li><li><a href="DateType.html">DateType</a></li><li><a href="DayType.html">DayType</a></li><li><a href="DoubleType.html">DoubleType</a></li><li><a href="EnumType.html">EnumType</a></li><li><a href="external-http.IncomingMessage.html">IncomingMessage</a></li><li><a href="external-http.ServerResponse.html">ServerResponse</a></li><li><a href="FlexUnsignedIntType.html">FlexUnsignedIntType</a></li><li><a href="FloatType.html">FloatType</a></li><li><a href="GrowableBuffer.html">GrowableBuffer</a></li><li><a href="IntType.html">IntType</a></li><li><a href="LongType.html">LongType</a></li><li><a href="MapType.html">MapType</a></li><li><a href="NamedChoiceType.html">NamedChoiceType</a></li><li><a href="OctetsType.html">OctetsType</a></li><li><a href="OptionalType.html">OptionalType</a></li><li><a href="PointerType.html">PointerType</a></li><li><a href="RecursiveType.html">RecursiveType</a></li><li><a href="SetType.html">SetType</a></li><li><a href="ShortType.html">ShortType</a></li><li><a href="StringType.html">StringType</a></li><li><a href="StructType.html">StructType</a></li><li><a href="TimeType.html">TimeType</a></li><li><a href="TupleType.html">TupleType</a></li><li><a href="Type.html">Type</a></li><li><a href="UnsignedByteType.html">UnsignedByteType</a></li><li><a href="UnsignedIntType.html">UnsignedIntType</a></li><li><a href="UnsignedLongType.html">UnsignedLongType</a></li><li><a href="UnsignedShortType.html">UnsignedShortType</a></li></ul><h3>Namespaces</h3><ul><li><a href="r.html">r</a></li></ul><h3>Global</h3><ul><li><a href="global.html#download">download</a></li><li><a href="global.html#getType">getType</a></li><li><a href="global.html#httpRespond">httpRespond</a></li><li><a href="global.html#isRegistered">isRegistered</a></li><li><a href="global.html#readType">readType</a></li><li><a href="global.html#readTypeAndValue">readTypeAndValue</a></li><li><a href="global.html#readValue">readValue</a></li><li><a href="global.html#registerType">registerType</a></li><li><a href="global.html#upload">upload</a></li><li><a href="global.html#writeType">writeType</a></li><li><a href="global.html#writeTypeAndValue">writeTypeAndValue</a></li><li><a href="global.html#writeValue">writeValue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
